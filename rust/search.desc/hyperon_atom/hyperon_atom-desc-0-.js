searchState.loadedDescShard("hyperon_atom", 0, "Contains types and functions which are necessary to create …\nAtoms are main components of the atomspace. There are four …\nIterator of the sub-atoms of the Atom.\nMutable iterator of the sub-atoms of the Atom.\nAlias for the list of traits required for the standard …\nBoxed iterator type to simplify type annotations\nConverts serializable grounded atom into native Rust type <code>T</code>…\nTrait for implementing custom execution logic. Using this …\nAlias for the list of traits required for a custom Rust …\nTrait for implementing custom matching logic. In order to …\nGrounded function execution error.\nAn expression which may encapsulate other atoms including …\nAn expression atom structure.\nTrait allows implementing grounded atom with custom …\nGrounded atom represents sub-symbolic data in the …\nA trait to erase an actual type of the grounded atom. Not …\nArgument is not recognized by function implementation. It …\nReturned intentionally to let [crate::metta::interpreter] …\nUnexpected runtime error thrown by code. When […\nSymbol represents some idea or concept. Two symbols having …\nA symbol atom structure.\nVariable is used to create patterns. Such pattern can be …\nA variable atom structure\nReturns reference to the custom execution API …\nReturns reference to the wrapped Rust value of type <code>T</code> if …\nReturns mutable reference to the wrapped Rust value of …\nReturns reference to the custom matching API …\nConstructs new instance of the Bindings with predefined …\nConstructs a new BindingsSet with predefined content. …\nReturns a reference to a vector of sub-atoms.\nReturns a mutable reference to a vector of sub-atoms.\nConverts atom into Rust value using <code>Self::default()</code> …\nExecutes grounded function on passed <code>args</code> and returns list …\nExecutes grounded function on passed <code>args</code> and returns list …\nConstructs expression out of array of children.\nConstructs new Atom using symplified syntax for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs grounded atom with customized behaviour. See …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts into a vector of sub-atoms.\nReturns true if expression doesn’t contain …\nReturn iterator through all sub-atoms of the Atom.\nReturn mutable iterator through all sub-atoms of the Atom.\nReturns an unique instance of the variable with the same …\nReturns <code>atom</code> with all variables replaced by unique …\nImplements custom matching logic of the grounded atom. …\nReturns either single empty matcher::Bindings instance if …\nReturns either single empty matcher::Bindings instance if …\nModule contains functions to match atoms and work with …\nReturns the name of the symbol.\nReturns name of the variable.\nConstructs new symbol from <code>name</code>. Not intended to be used …\nConstructs new expression from vector of sub-atoms. Not …\nConstructs new variable using <code>name</code> provided.  Usually …\nConstructs new constant variable instance using <code>name</code> …\nConstructs new variable using <code>name</code> and ‘id’ provided. …\nConstructs new variable instance by parsing name in format …\nReturns the name of the Rust type wrapped into Atom::Symbol…\nImplements serialization logic of the grounded atom. The …\nContains algorithms to walk through subexpressions of …\nConstructs new symbol atom with given <code>name</code>.\nConstructs new symbol atom. Can be used to construct <code>const</code> …\nReturns type of the grounded atom. Should return same type …\nConstructs grounded atom from Rust value automatically.\nConstructs variable out of name.\nGrounded function abstraction.\nStructure to wrap GroundedFunction instance to make an …\nReturns the argument unchanged.\nCompares two grounded atoms for equality\nCalls <code>U::from(self)</code>.\nReturns name of the grounded function to register it as a …\nConstructs new GroundedFunctionAtom instance. Name also is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nString type\nGrounded Rust string representation\nReturn reference to string slice\nReturns the argument unchanged.\nTry to convert an atom into <code>Str</code> instance\nConstruct new instance from string literal\nConstruct new instance from owned string\nCalls <code>U::from(self)</code>.\nA utility function to return the part of a string in …\nRepresents variable bindings. Keeps two kinds of relations …\nIterator over <code>(&amp;VariableAtom, Atom)</code> pairs in Bindings. …\nRepresents a set of Bindings instances resulting from an …\nIterator over atom matching results. Each result is an …\nAbstraction of the variable set. It is used to allow …\nTries to insert <code>value</code> as a binding for the <code>var</code>. If <code>self</code> …\nAsserts equality between two VariableAtoms.  If the …\nApplies bindings to atom and return it (see …\nApplies bindings to atom. Function replaces all variables …\nChecks if atoms are equal up to variables replacement.\nReturns true if var is a part of the set.\nRemove variable equalities from the Bindings and represent …\nCreates a new BindingsSet with <code>count</code> full matches\nCreates a new fully-constrained BindingsSet\nThis implementation is for testing only. It doesn’t take …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if bindings doesn’t contain any variable.\nReturns <code>true</code> if a BindingsSet contains no Bindings Objects …\nReturns <code>true</code> if a BindingsSet contains no limiting …\nIterate trough a list of variables in the set.\nReturns iterator of <code>(&amp;VariableAtom, Atom)</code> pairs to …\nMatches two atoms and returns an iterator over results. …\nMerges <code>b</code> bindings into self if they are compatible.  May …\nMerges each bindings from <code>other</code> to each bindings from <code>self</code>\nGet narrow bindings which contains only passed set of …\nConstructs new empty instance of Bindings.\nRename variables inside bindings using <code>rename</code>.\nReturns value of the variable with all sub-variables …\nCreates a new BindingsSet with a single full match\nAn iterator visiting all variables in arbitrary order.\nContains the error value\nSerialization error code\nSerialization of the type is not supported by serializer.\nContains the success value\nSerialization result type\nSerial module defines an API to implement …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSerialize bool value.\nSerialize f64 value.\nSerialize i64 value.\nSerialize string value.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")